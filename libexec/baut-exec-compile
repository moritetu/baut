#!/usr/bin/env bash

set -eu

source "$BAUT_LIBEXEC"/baut--load

declare -a test_functions=()
declare -A func_annotations=()
declare -a before_all_functions=()
declare -a after_all_functions=()
declare -a before_each_functions=()
declare -a after_each_functions=()
declare -a output_buffer=()

lineno=0
source_file=
line=


#: append_buffer
#:   Write arguments into buffer array.
#:
append_buffer() {
  for line in "$@"; do
    output_buffer[${#output_buffer[@]}]="$line"
  done
}


#: Compile


reset_function_state() {
  func_annotations=()
}

#: compile
#:   Compile $source_file.
#:
compile() {
  while IFS= read -r line; do
    let lineno=lineno+1

    # Process an annotation
    if [ "${line:0:2}" = "#:" ]; then
      parse_annotation "${line:2}"
      continue
    fi

    # Skip a comment line
    if [[ "$line" =~ ^[[:space:]]*# ]]; then
      continue
    fi

    # Process a function
    if [[ $line =~ ^(function)?[[:blank:]]*([^[:blank:]{()]+)[[:blank:]]*\(.*\)[[:blank:]]*\{ ]]; then
      local func_name="${BASH_REMATCH[2]}"
      if [ -n "$func_name" ]; then
        define_function "$func_name"
        reset_function_state
      fi
    fi
    append_buffer "$line"
  done < "$source_file"

  # Only report functions
  if [ ${options[countOnly]} -eq 1 ]; then
    print_test_count
  elif [ ${options[showFunctions]} -eq 1 ]; then
    print_test_functions
  else
    # Write compiled codes to the standard output
    output_all
  fi
}

#: parse_annotation <string>
#:   Parse an annotation.
#:
parse_annotation() {
  local text="$1"
  local ident=
  local value=
  # Syntax: @name(value)
  if [[ $text =~ @([a-zA-Z_]+)(\((.+)\))? ]]; then
    ident="${BASH_REMATCH[1]}"
    value="${BASH_REMATCH[3]}"
    if [ -n "$ident" ]; then
      case "$ident" in
        BeforeAll | BeforeEach | AfterAll | AfterEach | Ignore | Test | Deprecated | TODO)
          if [ -z "${func_annotations[$ident]:-}" ]; then
            func_annotations[$ident]="$value"
          else
            func_annotations[$ident]+="\n${value}"
          fi
          ;;
        *)
          log_warn "unknown annotation: $source_file(line:$lineno): $line"
          ;;
      esac
    fi
  fi
}

#: define_function <function>
#:   Define the function that should be executed.
#:
define_function() {
  local func_name="$1"
  local exec_func=
  local next_index=${#test_functions[@]}
  local tag
  if [ ${#func_annotations[@]} -ne 0 ]; then
    for tag in "${!func_annotations[@]}"; do
      case "$tag" in
        BeforeAll)
          before_all_functions[${#before_all_functions[@]}]="$func_name"
          return 0
          ;;
        BeforeEach)
          before_each_functions[${#before_each_functions[@]}]="$func_name"
          return 0
          ;;
        AfterAll)
          after_all_functions[${#after_all_functions[@]}]="$func_name"
          return 0
          ;;
        AfterEach)
          after_each_functions[${#after_each_functions[@]}]="$func_name"
          return 0
          ;;
        Ignore)
          exec_func=
          break
          ;;
        Test | Deprecated | TODO)
          exec_func="$func_name"
          hash_set "$func_name" "$tag" "1"
          hash_set "$func_name" "$tag" "value" "${func_annotations[$tag]}"
          ;;
        *)
          log_warn "unknown annotation: $tag"
          ;;
      esac
    done
    if [ -n "$exec_func" ]; then
      test_functions[$next_index]="$func_name"
    fi
  fi

  # We allow the function whose name starts with 'test_'.
  if [[ $func_name =~ ^test_* ]]; then
    test_functions[$next_index]="$func_name"
  fi
}


#: Output


#: output_all
#:   Write compiled source codes to the standard output.
#:
output_all() {
  if [ ${#output_buffer[@]} -eq 0 ]; then
    log_warn "nothing to output"
    exit
  fi
  output_header
  output_body
}

#: output_header
#:   Write compiled source codes header to the standard output.
#:
output_header() {
  local shbang="${output_buffer[0]}"
  local checksum="$(cat "$source_file" | "$baut_hash")"
  checksum="${checksum%% *}"
  if [[ $shbang =~ ^#!.* ]]; then
    echo "$shbang"
    unset output_buffer[0]
  else
    echo "#!/usr/bin/env bash"
  fi
  echo "# This source was generated by $(baut-version) at $(datetime)"
  echo "#:@filepath=$(resolve_link "$source_file")"
  echo "#:@checksum=$checksum"
  echo "#:@testcount=${#test_functions[@]}"
}

#: output_body
#:   Write compiled source codes body to the standard output.
#:   Compiled format is the following:
#:
#:   Load Segment        Load required libraries.
#:   Variable Segment    Define common variables readable in a series of tests in a file.
#:   Before Segment      Define processes before test execution.
#:   Execution Segment   Define test execution processes.
#:   After Segment       Define processes after test execution.
#:
output_body() {
  local test_file="$(resolve_link "$source_file")"

  # Load segment
  cat<<LOAD
readonly BAUT_TEST_FILE="$test_file"
readonly BAUT_TEST_FUNCTIONS=(${test_functions[@]:-})
readonly BAUT_LIBEXEC=\${BAUT_LIBEXEC:-"$BAUT_LIBEXEC"}
[ -e "\$BAUT_TEST_FILE" ] || abort "error: There is something wrong, file is not found: \$BAUT_TEST_FILE"
source "\$BAUT_TEST_FILE" || abort "error: failed to source '\$BAUT_TEST_FILE'"
require "baut--test-behavior" && load_if_exists "local--test-behavior" ||:
LOAD

  # Variable segment
  cat <<VARS
baut_run_test_suit() {
  declare -ar before_all_functions=(${before_all_functions[@]:-})
  declare -ar before_each_functions=(${before_each_functions[@]:-})
  declare -ar after_all_functions=(${after_all_functions[@]:-})
  declare -ar after_each_functions=(${after_each_functions[@]:-})
  local BAUT_TEST_FUNCTION_NAME=
VARS

  # Before segment
  cat<<BEFORE
  baut_before_all
BEFORE

  # Execution segment

  # Output for each function
  local i=1
  local deprecated= todo=
  local deprecated_value= func_alias_value= todo_value=
  for func_name in "${test_functions[@]}"; do
    echo "  # => $i: $func_name"
    echo "  BAUT_TEST_FUNCTION_NAME='${func_name}'"
    deprecated="$(hash_get "$func_name" "Deprecated")"
    deprecated_value="$(hash_get "$func_name" "Deprecated" "value")"
    func_alias_value="$(hash_get "$func_name" "Test" "value")"
    todo="$(hash_get "$func_name" "TODO")"
    todo_value="$(hash_get "$func_name" "TODO" "value")"
    # We run a test function in sub-process.
    printf "  (readonly BAUT_TEST_FUNCTION_NAME;"
    if [ -n "$deprecated" ]; then
      printf "%s;" "deprecated \"$(escape_double_quot "${deprecated_value:-$func_name}")\""
    fi
    if [ -z "$todo" ]; then
      printf "%s" "baut_run_test \"$(escape_double_quot "$func_alias_value")\")"
    else
      printf "%s" "baut_run_todo_test  \"$(escape_double_quot "$todo_value")\" \"$(escape_double_quot "$func_alias_value")\")"
    fi
    printf "\n"
    let i+=1
  done

  # After segment
cat <<AFTER
  BAUT_TEST_FUNCTION_NAME=
  baut_after_all
}
baut_start_test "baut_run_test_suit"
AFTER
}

#: print_test_functions
#:   Write test functions into the standard output.
#: ex: output format
#:     <label> <tab> <function> [<function> ...]
#:
print_test_functions() {
  printf "before_all_functions\t%s\n" "${before_all_functions[*]:-}"
  printf "before_each_functions\t%s\n" "${before_each_functions[*]:-}"
  printf "test_functions\t%s\n" "${test_functions[*]:-}"
  printf "after_each_functions\t%s\n" "${after_each_functions[*]:-}"
  printf "after_all_functions\t%s\n" "${after_all_functions[*]:-}"
}

#: print_test_count
#:   Write test count into the standard output.
#:
print_test_count() {
  printf "test_count\t%d\n" "${#test_functions[@]}"
}

#: escape_double_quot <string>
#:   Escape double quotations in the string.
#: ex: escape_double_quot 'hoge"foo'    => hoge\"foo
#:
escape_double_quot() {
  echo "$1" | sed -e 's/"/\\"/g'
}


# Arguments are required.
if [ $# -eq 0 ]; then
  abort "error: $(self): file is required: baut compile <file>"
fi

# Options
declare -A options
options=(
  [countOnly]=0          # Print test count
  [showFunctions]=0      # Print test functions
)

# parse_options
while [ $# -gt 0 ]; do
  case "$1" in
    --count-only)       options[countOnly]=1        ;;
    --show-functions)   options[showFunctions]=1    ;;
    -*)                 abort "error: $(self): invalid option: $1"  ;;
    *)
      if [ ! -e "$1" ]; then
        abort "error: $(self): file does not exist: $1"
      fi
      source_file="$1"
      break
      ;;
  esac
  shift
done

if [ -z "$source_file" ]; then
  abort "error: $(self): invalid argument: file is required"
fi

compile

exit

#=begin COMMAND
#
# compile    Compile a test script file.
#
#=end COMMAND

#=begin HELP
#
# Usage: baut compile [--count-only] [--show-functions] <file>
#
# Compile a test script file and write the result into the standard output.
#
# SYNOPSIS
#   baut compile --count-only <file>
#   baut compile --show-functions <file>
#
# OPTIONS
#   --count-only
#     Only print test function count in the specifiled file.
#     ex: test_count <tab> 7
#
#   --show-functions
#     Only print test functions in the specifiled file.
#     ex: test_functions <tab> <function> [<function> ...]
#
#
#=end HELP
